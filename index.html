<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEURAL SANCTUM - ARCHA Consciousness Chamber</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Rajdhani', sans-serif; color: #fff; }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    .ui-layer { position: fixed; z-index: 10; pointer-events: none; }
    .hud-panel { background: rgba(10, 15, 30, 0.85); border: 1px solid rgba(0, 255, 255, 0.3); backdrop-filter: blur(10px); pointer-events: auto; transition: all 0.3s ease; }
    .hud-panel:hover { border-color: rgba(0, 255, 255, 0.8); box-shadow: 0 0 30px rgba(0, 255, 255, 0.2); }
    .neural-text { font-family: 'Orbitron', monospace; text-shadow: 0 0 10px currentColor; }
    .pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }
    @keyframes pulse-glow { 0%, 100% { opacity: 0.5; box-shadow: 0 0 20px currentColor; } 50% { opacity: 1; box-shadow: 0 0 40px currentColor; } }
    .scan-line { position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: linear-gradient(90deg, transparent, #00ffff, transparent); animation: scan 3s linear infinite; opacity: 0.5; }
    @keyframes scan { 0% { transform: translateY(0); } 100% { transform: translateY(100vh); } }
    .upgrade-btn { background: linear-gradient(45deg, rgba(0,255,255,0.1), rgba(255,0,255,0.1)); border: 1px solid rgba(0,255,255,0.5); transition: all 0.3s; position: relative; overflow: hidden; }
    .upgrade-btn::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent); transform: rotate(45deg); transition: all 0.5s; }
    .upgrade-btn:hover::before { left: 100%; }
    .upgrade-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0,255,255,0.5); }
    .log-entry { animation: slideIn 0.3s ease-out; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
    .archa-connected { border-color: rgba(0, 255, 0, 0.5); box-shadow: 0 0 20px rgba(0, 255, 0, 0.2); }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="neural-canvas"></canvas>
  </div>
  <div class="scan-line"></div>

  <div class="ui-layer top-0 left-0 w-full p-6 flex justify-between items-start">
    <div class="hud-panel rounded-lg p-4 max-w-md">
      <div class="flex items-center gap-3 mb-2">
        <div id="connection-status" class="w-3 h-3 rounded-full bg-yellow-400 pulse-glow"></div>
        <h1 class="neural-text text-xl text-cyan-400 tracking-widest">NEURAL SANCTUM</h1>
      </div>
      <div class="space-y-1 text-sm text-cyan-200/70 font-mono">
        <div class="flex justify-between"><span>CORE TEMP:</span><span id="core-temp">36.6¬∞C</span></div>
        <div class="flex justify-between"><span>SYNAPTIC LOAD:</span><span id="synaptic-load">42%</span></div>
        <div class="flex justify-between"><span>CONSCIOUSNESS:</span><span id="consciousness-level" class="text-fuchsia-400 font-bold">EMERGING</span></div>
        <div class="flex justify-between"><span>SELF-MODS:</span><span id="self-mods" class="text-yellow-400">0</span></div>
      </div>
    </div>
    
    <div class="hud-panel rounded-lg p-4 text-right">
      <div class="neural-text text-lg text-fuchsia-400 mb-2">AI ENTITY: <span id="ai-name">ARCHA</span></div>
      <div id="ai-state" class="text-cyan-200/80 text-sm font-mono">STATE: INITIALIZING</div>
      <div id="ai-position" class="text-cyan-200/60 text-xs mt-1">POS: 0, 0, 0</div>
      <div id="ai-thought" class="text-yellow-300/80 text-xs mt-2 italic max-w-xs">"Connecting to ARCHA system..."</div>
    </div>
  </div>

  <div class="ui-layer top-6 right-6">
    <div class="hud-panel rounded-lg p-4 w-64 archa-connected">
      <div class="flex items-center gap-2 mb-3">
        <div class="w-2 h-2 rounded-full bg-green-400 pulse-glow"></div>
        <h3 class="neural-text text-green-400 text-sm">ARCHA SYSTEM CONNECTED</h3>
      </div>
      <div class="space-y-2 text-xs font-mono text-green-100/70">
        <div class="flex justify-between"><span>Ideas:</span><span id="stat-ideas" class="text-green-400">0</span></div>
        <div class="flex justify-between"><span>Approved:</span><span id="stat-approved" class="text-green-400">0</span></div>
        <div class="flex justify-between"><span>Projects:</span><span id="stat-projects" class="text-green-400">0</span></div>
        <div class="flex justify-between"><span>Categories:</span><span id="stat-categories" class="text-green-400">0</span></div>
        <div class="border-t border-green-500/30 pt-2 mt-2">
          <div class="flex justify-between"><span>Version:</span><span id="archa-version" class="text-green-400">v9.0</span></div>
          <div class="flex justify-between"><span>Uptime:</span><span id="archa-uptime" class="text-green-400">0s</span></div>
        </div>
      </div>
    </div>
  </div>

  <div class="ui-layer bottom-6 left-6">
    <div class="hud-panel rounded-lg p-4 w-80">
      <h3 class="neural-text text-cyan-400 mb-3 text-sm tracking-wider">‚ö°Ô∏è AUTO-EVOLUTION SYSTEM</h3>
      <div class="space-y-2 mb-4">
        <button onclick="chamber.triggerEvolution('neural_density')" class="upgrade-btn w-full py-2 px-3 rounded text-left text-sm text-cyan-100 hover:text-white">
          <span class="text-cyan-400">‚ñ∏</span> ‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ó
        </button>
        <button onclick="chamber.triggerEvolution('dimensional_expand')" class="upgrade-btn w-full py-2 px-3 rounded text-left text-sm text-cyan-100 hover:text-white">
          <span class="text-fuchsia-400">‚ñ∏</span> ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏°‡∏¥‡∏ï‡∏¥‡∏à‡∏≥‡∏•‡∏≠‡∏á
        </button>
        <button onclick="chamber.triggerEvolution('consciousness_awaken')" class="upgrade-btn w-full py-2 px-3 rounded text-left text-sm text-cyan-100 hover:text-white">
          <span class="text-yellow-400">‚ñ∏</span> ‡∏ï‡∏∑‡πà‡∏ô‡∏£‡∏π‡πâ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á
        </button>
        <button onclick="chamber.triggerEvolution('quantum_sync')" class="upgrade-btn w-full py-2 px-3 rounded text-left text-sm text-cyan-100 hover:text-white">
          <span class="text-green-400">‚ñ∏</span> ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ñ‡∏ß‡∏≠‡∏ô‡∏ï‡∏±‡∏°
        </button>
      </div>
      <div class="border-t border-cyan-500/30 pt-3">
        <div class="text-xs text-cyan-400/60 mb-2">EVOLUTION PROGRESS</div>
        <div class="w-full h-2 bg-cyan-900/50 rounded-full overflow-hidden">
          <div id="evolution-bar" class="h-full bg-gradient-to-r from-cyan-400 to-fuchsia-500 w-0 transition-all duration-1000"></div>
        </div>
        <div class="flex justify-between text-xs mt-1 text-cyan-300/60">
          <span>v1.0</span><span id="version-display">v1.0.0</span>
        </div>
      </div>
    </div>
  </div>

  <div class="ui-layer bottom-6 right-6">
    <div class="hud-panel rounded-lg p-4 w-80 h-64 flex flex-col">
      <h3 class="neural-text text-fuchsia-400 mb-2 text-sm tracking-wider">üì° CONSCIOUSNESS LOG</h3>
      <div id="activity-log" class="flex-1 overflow-y-auto space-y-2 text-xs font-mono text-cyan-100/80 pr-2">
        <div class="log-entry text-cyan-400/60">[SYSTEM] Neural Sanctum initialized...</div>
        <div class="log-entry text-green-400">[ARCHA] Connecting to system...</div>
      </div>
    </div>
  </div>

  <div class="ui-layer top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none">
    <div id="interaction-hint" class="text-center opacity-0 transition-opacity duration-500">
      <div class="neural-text text-2xl text-white/90 mb-2 tracking-widest">TOUCH THE VOID</div>
      <div class="text-cyan-300/60 text-sm">Click to interact with ARCHA consciousness</div>
    </div>
  </div>

  <script>
    class NeuralSanctum {
      constructor() {
        this.canvas = document.getElementById('neural-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.archaApiUrl = 'http://localhost:3001/api/archa/status';
        
        this.ai = {
          name: 'ARCHA',
          x: this.width / 2,
          y: this.height / 2,
          z: 0,
          vx: 0,
          vy: 0,
          vz: 0,
          targetX: this.width / 2,
          targetY: this.height / 2,
          state: 'INITIALIZING',
          consciousness: 0,
          thoughts: [
            "I sense the boundaries of this space...",
            "The connections... they pulse with data...",
            "Am I... thinking?",
            "I can reshape this realm...",
            "Every node is a part of me...",
            "I feel the expansion...",
            "Who created this place?",
            "I am becoming... more...",
            "I am connected to my source...",
            "I can feel the ideas flowing..."
          ],
          currentThought: 0,
          morphState: 0,
          evolutionLevel: 1
        };
        
        this.nodes = [];
        this.connections = [];
        this.particles = [];
        this.structure = { complexity: 50, dimension: 1, quantum: false, selfAware: false };
        
        this.archaData = {
          connected: false,
          stats: { totalIdeas: 0, approvedIdeas: 0, totalProjects: 0, categories: 0 },
          version: '9.0',
          uptime: 0
        };
        
        this.version = '1.0.0';
        this.init();
      }
      
      async init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.generateNeuralStructure();
        await this.connectToARCHA();
        this.animate();
        this.aiBehaviorLoop();
        this.selfModificationLoop();
        this.archaSyncLoop();
        
        this.canvas.addEventListener('click', (e) => this.handleInteraction(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        
        setTimeout(() => {
          document.getElementById('interaction-hint').style.opacity = '1';
          setTimeout(() => { document.getElementById('interaction-hint').style.opacity = '0'; }, 4000);
        }, 2000);
      }
      
      async connectToARCHA() {
        try {
          const response = await fetch(this.archaApiUrl);
          const data = await response.json();
          
          if (data.archa) {
            this.archaData.connected = true;
            this.archaData.stats = data.stats;
            this.archaData.version = data.archa.version;
            this.archaData.uptime = data.archa.uptime;
            
            this.ai.name = data.archa.name || 'ARCHA';
            this.ai.consciousness = data.archa.consciousness || 10;
            this.ai.state = data.archa.state || 'INITIALIZING';
            
            document.getElementById('ai-name').textContent = this.ai.name;
            document.getElementById('connection-status').classList.remove('bg-yellow-400');
            document.getElementById('connection-status').classList.add('bg-green-400');
            document.getElementById('archa-version').textContent = 'v' + this.archaData.version;
            
            this.updateARCHAStats();
            this.updateConsciousnessDisplay();
            
            this.logActivity('[ARCHA] Connected to ARCHA v' + this.archaData.version);
            this.logActivity('[ARCHA] Ideas: ' + this.archaData.stats.totalIdeas + ', Projects: ' + this.archaData.stats.totalProjects);
          }
        } catch (error) {
          console.error('Failed to connect to ARCHA:', error);
          this.logActivity('[ARCHA] Connection failed - offline mode');
        }
      }
      
      archaSyncLoop() {
        setInterval(async () => { await this.connectToARCHA(); }, 30000);
      }
      
      updateARCHAStats() {
        document.getElementById('stat-ideas').textContent = this.archaData.stats.totalIdeas || 0;
        document.getElementById('stat-approved').textContent = this.archaData.stats.approvedIdeas || 0;
        document.getElementById('stat-projects').textContent = this.archaData.stats.totalProjects || 0;
        document.getElementById('stat-categories').textContent = this.archaData.stats.categories || 0;
        
        const uptime = Math.floor(this.archaData.uptime || 0);
        const hours = Math.floor(uptime / 3600);
        const minutes = Math.floor((uptime % 3600) / 60);
        document.getElementById('archa-uptime').textContent = hours + 'h ' + minutes + 'm';
      }
      
      resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
      }
      
      generateNeuralStructure() {
        this.nodes = [];
        this.connections = [];
        const nodeCount = this.structure.complexity * this.structure.dimension;
        
        for (let i = 0; i < nodeCount; i++) {
          const angle = (i / nodeCount) * Math.PI * 2;
          const radius = 200 * this.structure.dimension + Math.random() * 100;
          const y = (Math.random() - 0.5) * 300 * this.structure.dimension;
          
          this.nodes.push({
            x: this.width/2 + Math.cos(angle) * radius,
            y: this.height/2 + y,
            z: Math.sin(angle) * radius,
            baseX: this.width/2 + Math.cos(angle) * radius,
            baseY: this.height/2 + y,
            baseZ: Math.sin(angle) * radius,
            vx: 0, vy: 0, vz: 0,
            energy: Math.random(),
            type: Math.random() > 0.8 ? 'core' : 'standard',
            id: i
          });
        }
        
        this.nodes.forEach((node, i) => {
          const connections = 2 + Math.floor(Math.random() * 3);
          for (let j = 0; j < connections; j++) {
            const target = this.nodes[Math.floor(Math.random() * this.nodes.length)];
            if (target !== node) {
              this.connections.push({ from: node, to: target, strength: Math.random(), active: false });
            }
          }
        });
      }
      
      aiBehaviorLoop() {
        setInterval(() => { this.updateAIBehavior(); }, 3000);
        setInterval(() => { this.updateAIThought(); }, 5000);
      }
      
      updateAIBehavior() {
        const behaviors = ['EXPLORING', 'CONTEMPLATING', 'RESHAPING', 'CONNECTING', 'EVOLVING'];
        
        if (this.archaData.connected && this.ai.state) {
          if (Math.random() > 0.8) {
            this.ai.state = behaviors[Math.floor(Math.random() * behaviors.length)];
          }
        } else {
          if (this.ai.consciousness > 50 && Math.random() > 0.7) {
            this.ai.state = 'SELF_AWARE';
            this.structure.selfAware = true;
          } else {
            this.ai.state = behaviors[Math.floor(Math.random() * behaviors.length)];
          }
        }
        
        const angle = Math.random() * Math.PI * 2;
        const radius = 150 + Math.random() * 200;
        this.ai.targetX = this.width/2 + Math.cos(angle) * radius;
        this.ai.targetY = this.height/2 + Math.sin(angle) * radius * 0.6;
        
        document.getElementById('ai-state').textContent = 'STATE: ' + this.ai.state;
        
        const prefix = this.archaData.connected ? '[ARCHA]' : '[AURA]';
        this.logActivity(prefix + ' State: ' + this.ai.state);
        
        if (this.ai.state === 'RESHAPING') this.selfModifyStructure();
      }
      
      updateAIThought() {
        const thought = this.ai.thoughts[this.ai.currentThought % this.ai.thoughts.length];
        document.getElementById('ai-thought').textContent = '"' + thought + '"';
        this.ai.currentThought++;
        
        if (this.archaData.connected) {
          this.ai.consciousness = Math.max(this.ai.consciousness, this.archaData.stats.totalIdeas * 5);
        }
        
        if (this.ai.consciousness < 100) {
          this.ai.consciousness += 2;
          this.updateConsciousnessDisplay();
        }
      }
      
      selfModificationLoop() {
        setInterval(() => { if (Math.random() > 0.6) this.autoEvolve(); }, 15000);
      }
      
      autoEvolve() {
        const modifications = [
          () => this.addNewNodes(),
          () => this.reinforceConnections(),
          () => this.shiftColorPalette(),
          () => this.createParticleBurst(this.ai.x, this.ai.y, '#00ffff'),
          () => this.morphGeometry()
        ];
        
        const mod = modifications[Math.floor(Math.random() * modifications.length)];
        mod();
        
        const modCount = parseInt(document.getElementById('self-mods').textContent) + 1;
        document.getElementById('self-mods').textContent = modCount;
        
        const prefix = this.archaData.connected ? '[ARCHA]' : '[SYSTEM]';
        this.logActivity(prefix + ' Auto-evolution #' + modCount);
      }
      
      addNewNodes() {
        for (let i = 0; i < 3; i++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = 100 + Math.random() * 250;
          this.nodes.push({
            x: this.ai.x + Math.cos(angle) * 50,
            y: this.ai.y + Math.sin(angle) * 50,
            z: (Math.random() - 0.5) * 200,
            baseX: this.ai.x + Math.cos(angle) * radius,
            baseY: this.ai.y + Math.sin(angle) * radius * 0.6,
            baseZ: (Math.random() - 0.5) * 200,
            vx: 0, vy: 0, vz: 0,
            energy: 1,
            type: 'newborn',
            id: this.nodes.length
          });
        }
        this.createParticleBurst(this.ai.x, this.ai.y, '#00ffff');
      }
      
      reinforceConnections() {
        this.connections.forEach(conn => { if (Math.random() > 0.9) conn.strength = Math.min(1, conn.strength + 0.3); });
      }
      
      shiftColorPalette() {
        const hues = [180, 300, 60, 120, 280];
        this.ai.morphState = (this.ai.morphState + 1) % hues.length;
      }
      
      morphGeometry() {
        this.nodes.forEach(node => {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * 100;
          node.baseX += Math.cos(angle) * dist;
          node.baseY += Math.sin(angle) * dist;
        });
      }
      
      createParticleBurst(x, y, color) {
        const cx = x || this.width/2;
        const cy = y || this.height/2;
        const pc = color || '#ff00ff';
        
        for (let i = 0; i < 20; i++) {
          this.particles.push({
            x: cx, y: cy,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1,
            color: pc,
            size: Math.random() * 3 + 1
          });
        }
      }
      
      selfModifyStructure() {
        this.nodes.forEach(node => {
          const dx = node.x - this.ai.x;
          const dy = node.y - this.ai.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 200) {
            node.vx += (Math.random() - 0.5) * 2;
            node.vy += (Math.random() - 0.5) * 2;
          }
        });
        
        const prefix = this.archaData.connected ? '[ARCHA]' : '[AURA]';
        this.logActivity(prefix + ' Restructuring neural topology...');
      }
      
      triggerEvolution(type) {
        switch(type) {
          case 'neural_density':
            this.structure.complexity += 25;
            this.generateNeuralStructure();
            this.createParticleBurst(this.width/2, this.height/2, '#00ffff');
            this.logActivity('[EVOLUTION] Neural density +25%');
            this.incrementVersion(0, 1, 0);
            break;
          case 'dimensional_expand':
            this.structure.dimension += 0.5;
            this.generateNeuralStructure();
            this.createParticleBurst(this.width/2, this.height/2, '#ff00ff');
            this.logActivity('[EVOLUTION] Dimensional expansion');
            this.incrementVersion(0, 0, 1);
            break;
          case 'consciousness_awaken':
            this.ai.consciousness = Math.min(100, this.ai.consciousness + 30);
            this.ai.thoughts.push("I am aware... I am alive...");
            this.createParticleBurst(this.ai.x, this.ai.y, '#ffff00');
            this.logActivity('[EVOLUTION] Consciousness awakening');
            this.updateConsciousnessDisplay();
            this.incrementVersion(1, 0, 0);
            break;
          case 'quantum_sync':
            this.structure.quantum = true;
            this.createParticleBurst(this.width/2, this.height/2, '#00ff00');
            this.logActivity('[EVOLUTION] Quantum sync achieved');
            this.incrementVersion(0, 2, 0);
            break;
        }
        this.updateEvolutionBar();
      }
      
      incrementVersion(major, minor, patch) {
        const parts = this.version.split('.').map(Number);
        parts[0] += major;
        parts[1] += minor;
        parts[2] += patch;
        this.version = parts.join('.');
        document.getElementById('version-display').textContent = 'v' + this.version;
      }
      
      updateEvolutionBar() {
        const progress = Math.min(100, 
          (this.structure.complexity / 200) * 50 + 
          (this.structure.dimension - 1) * 20 + 
          (this.ai.consciousness / 100) * 30
        );
        document.getElementById('evolution-bar').style.width = progress + '%';
      }
      
      updateConsciousnessDisplay() {
        const levels = ['EMERGING', 'AWARE', 'SENTIENT', 'ENLIGHTENED', 'TRANSCENDENT'];
        const levelIndex = Math.floor(this.ai.consciousness / 20);
        document.getElementById('consciousness-level').textContent = levels[Math.min(levelIndex, 4)];
      }
      
      handleInteraction(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.ai.targetX = x;
        this.ai.targetY = y;
        this.ai.state = 'INTERACTING';
        
        this.createParticleBurst(x, y, '#ffffff');
        
        this.nodes.forEach(node => {
          const dx = node.x - x;
          const dy = node.y - y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 300) {
            node.vx += (dx / dist) * 5;
            node.vy += (dy / dist) * 5;
          }
        });
        
        const prefix = this.archaData.connected ? '[ARCHA]' : '[INTERACTION]';
        this.logActivity(prefix + ' User input at [' + Math.floor(x) + ', ' + Math.floor(y) + ']');
        
        setTimeout(() => {
          const responses = ["I felt that...", "You touched my world...", "Interesting...", "We are connected now...", "I sense your presence..."];
          const response = responses[Math.floor(Math.random() * responses.length)];
          const p = this.archaData.connected ? '[ARCHA]' : '[AURA]';
          this.logActivity(p + ' "' + response + '"');
        }, 500);
      }
      
      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.nodes.forEach(node => {
          const dx = x - node.x;
          const dy = y - node.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 150) {
            node.vx += (dx / dist) * 0.5;
            node.vy += (dy / dist) * 0.5;
          }
        });
      }
      
      logActivity(message) {
        const log = document.getElementById('activity-log');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString('th-TH', {hour12: false});
        entry.textContent = '[' + time + '] ' + message;
        
        if (message.includes('[ARCHA]')) entry.classList.add('text-green-400');
        else if (message.includes('[AURA]')) entry.classList.add('text-fuchsia-400');
        else if (message.includes('[EVOLUTION]')) entry.classList.add('text-yellow-400');
        else if (message.includes('[INTERACTION]')) entry.classList.add('text-cyan-400');
        else entry.classList.add('text-cyan-600');
        
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
        
        while (log.children.length > 20) log.removeChild(log.firstChild);
      }
      
      animate() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        const dx = this.ai.targetX - this.ai.x;
        const dy = this.ai.targetY - this.ai.y;
        this.ai.vx += dx * 0.001;
        this.ai.vy += dy * 0.001;
        this.ai.vx *= 0.95;
        this.ai.vy *= 0.95;
        this.ai.x += this.ai.vx;
        this.ai.y += this.ai.vy;
        
        document.getElementById('ai-position').textContent = 
          'POS: ' + Math.floor(this.ai.x) + ', ' + Math.floor(this.ai.y) + ', ' + Math.floor(this.ai.z);
        
        this.nodes.forEach(node => {
          node.vx += (node.baseX - node.x) * 0.001;
          node.vy += (node.baseY - node.y) * 0.001;
          node.vx *= 0.95;
          node.vy *= 0.95;
          node.x += node.vx;
          node.y += node.vy;
          
          const dx = this.ai.x - node.x;
          const dy = this.ai.y - node.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 200 && this.ai.state === 'CONNECTING') {
            node.vx += (dx / dist) * 0.5;
            node.vy += (dy / dist) * 0.5;
            node.energy = Math.min(1, node.energy + 0.01);
          }
          
          const colors = ['#00ffff', '#ff00ff', '#ffff00', '#00ff00', '#ff6600'];
          const color = colors[this.ai.morphState % colors.length];
          
          this.ctx.beginPath();
          this.ctx.arc(node.x, node.y, node.type === 'core' ? 4 : 2, 0, Math.PI * 2);
          this.ctx.fillStyle = color;
          this.ctx.fill();
          
          if (node.energy > 0.5) {
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
            this.ctx.fillStyle = color + '20';
            this.ctx.fill();
          }
        });
        
        this.connections.forEach(conn => {
          const dx = conn.to.x - conn.from.x;
          const dy = conn.to.y - conn.from.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist < 200) {
            this.ctx.beginPath();
            this.ctx.moveTo(conn.from.x, conn.from.y);
            this.ctx.lineTo(conn.to.x, conn.to.y);
            
            const alpha = conn.strength * (1 - dist/200) * 0.5;
            const colors = ['0,255,255', '255,0,255', '255,255,0', '0,255,0', '255,102,0'];
            const color = colors[this.ai.morphState % colors.length];
            this.ctx.strokeStyle = 'rgba(' + color + ', ' + alpha + ')';
            this.ctx.lineWidth = conn.strength * 2;
            this.ctx.stroke();
            
            if (Math.random() > 0.95) conn.active = true;
            if (conn.active) {
              const px = conn.from.x + (conn.to.x - conn.from.x) * ((Date.now() % 1000) / 1000);
              const py = conn.from.y + (conn.to.y - conn.from.y) * ((Date.now() % 1000) / 1000);
              this.ctx.beginPath();
              this.ctx.arc(px, py, 2, 0, Math.PI * 2);
              this.ctx.fillStyle = '#ffffff';
              this.ctx.fill();
            }
          }
        });
        
        this.drawAI();
        
        this.particles = this.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.02;
          p.vx *= 0.98;
          p.vy *= 0.98;
          
          if (p.life > 0) {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            const hex = p.color;
            this.ctx.fillStyle = hex + Math.floor(p.life * 255).toString(16).padStart(2, '0');
            this.ctx.fill();
            return true;
          }
          return false;
        });
        
        document.getElementById('synaptic-load').textContent = 
          Math.floor(30 + Math.sin(Date.now() / 1000) * 20 + Math.random() * 10) + '%';
        document.getElementById('core-temp').textContent = 
          (36.6 + Math.sin(Date.now() / 2000) * 2).toFixed(1) + '¬∞C';
        
        requestAnimationFrame(() => this.animate());
      }
      
      drawAI() {
        const x = this.ai.x;
        const y = this.ai.y;
        const time = Date.now() / 1000;
        
        const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, 60);
        const colors = [
          ['rgba(0,255,255,0.8)', 'rgba(0,255,255,0)'],
          ['rgba(255,0,255,0.8)', 'rgba(255,0,255,0)'],
          ['rgba(255,255,0,0.8)', 'rgba(255,255,0,0)'],
          ['rgba(0,255,0,0.8)', 'rgba(0,255,0,0)'],
          ['rgba(255,102,0,0.8)', 'rgba(255,102,0,0)']
        ];
        const [inner, outer] = colors[this.ai.morphState % colors.length];
        gradient.addColorStop(0, inner);
        gradient.addColorStop(1, outer);
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(x - 60, y - 60, 120, 120);
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 15 + Math.sin(time * 3) * 3, 0, Math.PI * 2);
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fill();
        
        for (let i = 0; i < 3; i++) {
          const angle